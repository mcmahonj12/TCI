#Requires -Modules VMware.VimAutomation.Core, VM.Ovf.Property
function Install-vCSA{
<#
.SYNOPSIS
This PowerCLI cmdlet create a PowerCli object OvfConfiguration specifically designed to be used when importing the VMware-vCenter-Server-Appliance-7.0.3.01000-20395099_OVF10 ovf/ova package with the Import-VApp cmdlet.
It relies on the get-ovfconfiguration PowerCli cmdlet

.DESCRIPTION
This function is based on the original get-ovfconfiguration PowerCLI cmdlet...
...and convert it in a Powershell friendly function specifically for the package VMware-vCenter-Server-Appliance-7.0.3.01000-20395099_OVF10
It is mandatory to be connected to one vCenter or Get-OvfConfiguration will throw an error.
The vCenter Server appliance OVA must be stored in a destination vCenter Content Library.

.NOTES
Author:Jim McMahon II
Original: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/Get-OvfConfiguration_on_steroids


.LINK
This function has been generated by script for a VMware-vCenter-Server-Appliance-7.0.3.01000-20395099_OVF10 ovf/ova package.
The script used to create this function is available at the link below, and can be used for any ovf/ova packages.
http://www.thecrazyconsultant.com/Get-OvfConfiguration_on_steroids
Documentation for the original get-ovfconfiguration
http://pubs.vmware.com/vsphere-55/index.jsp#com.vmware.powercli.cmdletref.doc/Get-OvfConfiguration.html
Link for a good overview of get-ovfconfiguration
http://blogs.vmware.com/PowerCLI/2014/09/powercli-5-8-new-feature-get-ovfconfiguration-part-1-2.html

.PARAMETER jsonpath
Specifies the file path to the json payload to be used to deploy a vCenter Server appliance. This payload is used to create the OVF properties object.

.PARAMETER ovfpath
Specifies the OVF or OVA package name stored in the destination vCenter Server Content Library for which the user-configurable options are returned. 
URL paths are not supported.

.EXAMPLE
Install-vCSA -JSONPath $file -$OVAName "vCenter-Server-Appliance-7"
#>
	<#param(
	$Common_guestinfo_cis_appliance_net_addr_family,
	$Common_guestinfo_cis_appliance_net_addr_1,
	$Common_guestinfo_cis_appliance_net_dns_servers,
	$Common_guestinfo_cis_appliance_net_gateway,
	$Common_guestinfo_cis_appliance_net_mode,
	$Common_guestinfo_cis_appliance_net_pnid,
	$Common_guestinfo_cis_appliance_net_prefix,
	$Common_guestinfo_cis_appliance_root_passwd,
	[boolean]$Common_guestinfo_cis_ceip_enabled = $False,
	[boolean]$Common_guestinfo_cis_hadcs_enabled = $True,
	$Common_guestinfo_cis_vmdir_password,
	$Common_guestinfo_cis_vpxd_ha_management_addr,
	$Common_guestinfo_cis_vpxd_ha_management_password,
	$Common_guestinfo_cis_vpxd_ha_management_port = "443",
	$Common_guestinfo_cis_vpxd_ha_management_thumbprint,
	$Common_guestinfo_cis_vpxd_ha_management_user,
	$Common_guestinfo_cis_vpxd_ha_placement,
	[ValidateSet("tiny", "small", "medium", "large", "xlarge", "tiny-lstorage", "small-lstorage", "medium-lstorage", "large-lstorage", "xlarge-lstorage", "tiny-xlstorage", "small-xlstorage", "medium-xlstorage", "large-xlstorage", "xlarge-xlstorage")]
	$DeploymentOption = "tiny",
	[ValidateSet("IPv4", "IPv6")]
	$IpAssignment_IpProtocol,
	$NetworkMapping_Network_1,
	$vami_VMware_vCenter_Server_Appliance_domain,
	$vami_VMware_vCenter_Server_Appliance_searchpath,
	[Parameter(Mandatory=$true,HelpMessage="Enter the local full path including extension to a VMware-vCenter-Server-Appliance-7.0.3.01000-20395099_OVF10.ovf or .ova file. This script has been designed to work only with this package.")]
	[ValidateScript({($_.split('\')[-1]) -eq 'VMware-vCenter-Server-Appliance-7.0.3.01000-20395099_OVF10.ova' -or ($_.split('\')[-1]) -eq 'VMware-vCenter-Server-Appliance-7.0.3.01000-20395099_OVF10.ovf' })]
	$ovfpath
	)#>
	[cmdletbinding()]
    param(
	  ## Specifies the json payload to be used to create an OVF properties object.
      [Parameter(Mandatory = $true)]
      [string]$JSONPath,
	  
	  ## Specifies the name of the OVA used to deploy the vCenter Server appliance.
	  [Parameter(Mandatory = $true)]
      [string]$OVAName
    )
	
  # Function sets the ovf properties from the specified JSON configuration file. Will only set those which contain data in the JSON.
    function Set-OvfParameters($params, $OvfConfiguration) {
		
		process{
		#Get ovf configuration from a local file
        #$OvfConfiguration = Get-OvfConfiguration -Ovf $params.vSphere.ovapath
		#$OvfConfiguration = Get-OvfConfiguration -ContentLibraryItem $ova -Target (Get-Inventory $params.new_vcsa.vc.vmhost)

		if($params.new_vcsa.network.ip_family){
		$OvfConfiguration.Common.guestinfo.cis.appliance.net.addr.family.Value = $params.new_vcsa.network.ip_family
		}
		if($params.new_vcsa.network.mode){
		$OvfConfiguration.Common.guestinfo.cis.appliance.net.mode.Value = $params.new_vcsa.network.mode
		}
		if($params.new_vcsa.network.ip){
		$OvfConfiguration.Common.guestinfo.cis.appliance.net.addr_1.Value = $params.new_vcsa.network.ip
		}
		if($params.new_vcsa.network.prefix){
		$OvfConfiguration.Common.guestinfo.cis.appliance.net.prefix.Value = $params.new_vcsa.network.prefix
		}
		if($params.new_vcsa.network.gateway){
		$OvfConfiguration.Common.guestinfo.cis.appliance.net.gateway.Value = $params.new_vcsa.network.gateway
		}
		if($params.new_vcsa.network.dns_servers){
		$OvfConfiguration.Common.guestinfo.cis.appliance.net.dns.servers.Value = $params.new_vcsa.network.dns_servers
		}
		if($params.new_vcsa.network.system_name){
		$OvfConfiguration.Common.guestinfo.cis.appliance.net.pnid.Value = $params.new_vcsa.network.system_name
		}
		if($params.new_vcsa.sso.password){
		$OvfConfiguration.Common.guestinfo.cis.vmdir.password.Value = $params.new_vcsa.sso.password
		}
		if($params.new_vcsa.os.password){
		$OvfConfiguration.Common.guestinfo.cis.appliance.root.passwd.Value = $params.new_vcsa.os.password
		}
		if($params.ceip.settings.ceip_enabled){
		$OvfConfiguration.Common.guestinfo.cis.ceip_enabled.Value = $params.ceip.settings.ceip_enabled
		}
		if($params.new_vcsa.appliance.deployment_option){
		$OvfConfiguration.DeploymentOption.Value = $params.new_vcsa.appliance.deployment_option
		}
		if($params.new_vcsa.vc.deployment_network){
		$OvfConfiguration.NetworkMapping.Network_1.Value = $params.new_vcsa.vc.deployment_network
		}
		if($params.new_vcsa.network.domain){
		$OvfConfiguration.vami.VMware_vCenter_Server_Appliance.domain.Value = $params.new_vcsa.network.domain
		}
		if($params.new_vcsa.network.searchpath){
		$OvfConfiguration.vami.VMware_vCenter_Server_Appliance.searchpath.Value = $params.new_vcsa.network.searchpath
		}
		if($OvfConfiguration.EULAs.Accept){
		$OvfConfiguration.EULAs.Accept.Value = $true
		}

		Return $OvfConfiguration
		}
	}

	$ErrorActionPreference = 'Stop'
	
	# Get JSON parameters from the specified config file which should be set in the OVF parameters hashtable.
	# If the path does not exist or the path is not a JSON exit the script with an error.
	Try {
		if (Resolve-Path $JSONPath -ErrorAction Stop) {
			if (([IO.Path]::GetExtension($JSONPath)) -ne ".json") {
				Write-Warning "The file extension specified is not supported. Retry the deployment with a .json extension. Stopping the script."
			}
		}
		$paramDataJSON = Get-Content -Path $JSONPath | Out-String
	}
	Catch {
		Write-Warning "The file path $JSONPath does not exist. Please retry the deployment with another path to the vCenter Server configuration JSON."
	}
      #$paramDataJSON = Get-Content -Path $JSONPath | Out-String
	# Try to convert the json file to a PowerShell object. If the file is not a valid JSON, exit the script.
	Try {
		$paramData = ConvertFrom-Json -InputObject $paramDataJSON -ErrorAction Stop
		#$paramData = ConvertFrom-Json -InputObject $JSON -ErrorAction Stop
	}
	Catch {
		Write-Warning "Could not convert the JSON file specified. $_"
	}
	
	# Try to obtain the OVF configuration data from the specified OVA.
	# If the OVA cannot be located exit the script.
	Try {
		$ovf = Get-OvfConfiguration -ContentLibraryItem $OVAName -Target ($paramData.new_vcsa.vc.vmhost) -ErrorAction Stop
	}
	Catch {
		Write-Warning "The specified ova $OVAName could not be located in the target vCenter Server's content libraries."
		Write-Warning "Please correct the name or upload the desired vCenter Server OVA and retry the deployment."
	}
    
      # Determine destination ESXi host (required New-VM parameter). Will get a host from a cluster object.
      $obj = Get-Inventory -Name $paramData.new_vcsa.vc.vmhost
      if ($obj -is [VMware.VimAutomation.ViCore.Impl.V1.Inventory.ComputeResourceImpl]) {
        $obj = Get-VMHost -Location $obj | Get-Random
      }
      $esx = $obj
     
	  # Set the destination datastore for the VM.
      $ds = Get-Datastore -Name $paramData.new_vcsa.vc.datastore -ErrorAction SilentlyContinue
    
      # Set OVF parameters for the VM deployment
      $ovfParam = Set-OvfParameters $paramData $ovf
	      
	 # VM configuration hashtable. Used to deploy a new VM.
      $sVApp = @{
        Name              = $paramData.new_vcsa.appliance.name
		VMHost            = $esx
        Datastore         = $ds
		DiskStorageFormat = [VMware.VimAutomation.ViCore.Types.V1.VirtualDevice.VirtualDiskStorageFormat]::Thin
		ContentLibraryItem = $OVAName
        OvfConfiguration  = $ovfParam
        Confirm           = $false
      }
	  # Add a folder location to the confguration hashtable if a folder location has been specified in the config file.
      if($paramData.new_vcsa.vc.vm_folder){
		# If the configuration JSON contains a folder name check if the folder exists.
		$data = get-folder -Type VM | Where-Object {$_.name -eq $paramData.new_vcsa.vc.vm_folder}
		
		# If the folder does not exist, create the folder in the VM root.
		if (!($data)) {Get-Folder vm | New-Folder $paramData.new_vcsa.vc.vm_folder -ErrorAction SilentlyContinue}
		
		# Add the folder as a location parameter to the deployment options.
        #$sVApp.Add('InventoryLocation',(Get-Folder $paramData.VM.Folder))
		$sVApp.Add('Location',(Get-Folder $paramData.new_vcsa.vc.vm_folder))
      }
      #$vm = Import-VApp @sVApp
	  
	#Deploy a new VM using the configuration hashtable. If the VM fails to be created, stop the script.
	try {
		Write-Host "Deploying vCenter appliance..."
		New-VM @sVApp -ErrorAction Stop
	}
	catch {
		Write-Warning "Could not create VM vcsa."
		Write-Host -ForegroundColor Yellow -BackgroundColor Black "$_.Exception"
		Write-Host -ForegroundColor Yellow -BackgroundColor Black "Check destination host logs for more information."
	}
    
	#Once the vCenter appliance is deployed, add additional properties to the VM before starting the VM.
	#These properties are required to fully configure the vCenter Server appliance automatically.
	#If the properties are not applied the vCenter Server will require Stage 2 configuration manually.
    
	#Get the vCenter Server appliance VM object.
	$vm = Get-VM -Name $paramData.new_vcsa.appliance.name
	
	#Create the addtional configuration properties hashtable.
	$vAppProperties = @{
		"guestinfo.cis.appliance.ntp.servers" = $paramData.new_vcsa.os.ntp_servers
		"guestinfo.cis.appliance.ssh.enabled" = $paramData.new_vcsa.os.ssh_enabled
		"guestinfo.cis.silentinstall" = "True"
		"guestinfo.cis.deployment.autoconfig" = "True"
	}
	
	#Set the additional properties on the vCenter Server appliance VM. This function is a custom function from William Lam.
	Set-VMOvfProperty -VM $vm -ovfChanges $vAppProperties
    
	#Once the properties are set start the VM.
    Start-VM $vm
	
	#Start checking if the appliance services are available. It may take up to 20 minutes to complete the appliance configuration.
	Write-Host "Will now attempt to connect to $($paramData.new_vcsa.network.system_name)  to validate it has come online properly."
	$i = 0
	do {
		Write-Host "$($paramData.new_vcsa.network.system_name) is not currently available. Retrying in 60 seconds."
		$i++
		Start-Sleep 60
	}
	until (($vi = connect-viserver -server $paramData.new_vcsa.network.system_name -user "administrator@vsphere.local" -password $paramData.new_vcsa.sso.password -ErrorAction SilentlyContinue) -or ($i -eq 25))

	#If the connection was successful inform the operator so.
	if ($vi) {
		Write-Host "Successfully connected to vCenter Server "
	}
	#If the connection was unsuccessful inform the operator the vCenter Server may still be configuring but the timeout was met.
	else
		{
		Write-Warning "Could not connect to vCenter Server . Timeout of 20 minutes was reached."
		Write-Warning "Check the vCenter Server appliance for more details. It may still be configuring."
	}
	  
	#Return the connection status for the vCenter Appliance so it may be used to perform other configurations.
	return $vi
}