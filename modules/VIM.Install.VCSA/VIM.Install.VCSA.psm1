#Requires -Modules VMware.VimAutomation.Core, VM.Ovf.Property
function Install-vCSA {
	<#
	.SYNOPSIS
	This PowerCLI cmdlet create a PowerCli object OvfConfiguration specifically designed to be used when importing the VMware-vCenter-Server-Appliance-7.0.3.01000-20395099_OVF10 ovf/ova package with the Import-VApp cmdlet.
	It relies on the get-ovfconfiguration PowerCli cmdlet
	
	.DESCRIPTION
	This function is based on the original get-ovfconfiguration PowerCLI cmdlet...
	...and convert it in a Powershell friendly function specifically for the package VMware-vCenter-Server-Appliance-7.0.3.01000-20395099_OVF10
	It is mandatory to be connected to one vCenter or Get-OvfConfiguration will throw an error.
	The vCenter Server appliance OVA must be stored in a destination vCenter Content Library.
	
	.NOTES
	Author:Jim McMahon II
	Original: Christophe Calvet
	Blog: http://www.thecrazyconsultant.com/Get-OvfConfiguration_on_steroids
	
	
	.LINK
	This function has been generated by script for a VMware-vCenter-Server-Appliance-7.0.3.01000-20395099_OVF10 ovf/ova package and modified to use a JSON payload.
	The script used to create this function is available at the link below, and can be used for any ovf/ova packages.
	http://www.thecrazyconsultant.com/Get-OvfConfiguration_on_steroids
	Documentation for the original get-ovfconfiguration
	http://pubs.vmware.com/vsphere-55/index.jsp#com.vmware.powercli.cmdletref.doc/Get-OvfConfiguration.html
	Link for a good overview of get-ovfconfiguration
	http://blogs.vmware.com/PowerCLI/2014/09/powercli-5-8-new-feature-get-ovfconfiguration-part-1-2.html
	
	.PARAMETER jsonpath
	Specifies the file path to the json payload to be used to deploy a vCenter Server appliance. This payload is used to create the OVF properties object.
	
	.PARAMETER ovfpath
	Specifies the OVF or OVA package name stored in the destination vCenter Server Content Library for which the user-configurable options are returned. 
	URL paths are not supported.
	
	.EXAMPLE
	Install-vCSA -JSONPath $file -$OVAName "vCenter-Server-Appliance-7"
	#>
	
	[cmdletbinding()]
	param(
		## Specifies the json payload to be used to create an OVF properties object.
		[Parameter(Mandatory = $true)]
		[string]$JSONPath,
		  
		## Specifies the name of the OVA used to deploy the vCenter Server appliance.
		[Parameter(Mandatory = $true)]
		[string]$OVAName
	)
		
	# Function sets the ovf properties from the specified JSON configuration file. Will only set those which contain data in the JSON.
	function Set-OvfParameters($params, $OvfConfiguration) {
			
		process {
			#Get ovf configuration from a local file
			#$OvfConfiguration = Get-OvfConfiguration -Ovf $params.vSphere.ovapath
			#$OvfConfiguration = Get-OvfConfiguration -ContentLibraryItem $ova -Target (Get-Inventory $params.new_vcsa.vc.vmhost)
	
			if ($params.new_vcsa.network.ip_family) {
				$OvfConfiguration.Common.guestinfo.cis.appliance.net.addr.family.Value = $params.new_vcsa.network.ip_family
			}
			if ($params.new_vcsa.network.mode) {
				$OvfConfiguration.Common.guestinfo.cis.appliance.net.mode.Value = $params.new_vcsa.network.mode
			}
			if ($params.new_vcsa.network.ip) {
				$OvfConfiguration.Common.guestinfo.cis.appliance.net.addr_1.Value = $params.new_vcsa.network.ip
			}
			if ($params.new_vcsa.network.prefix) {
				$OvfConfiguration.Common.guestinfo.cis.appliance.net.prefix.Value = $params.new_vcsa.network.prefix
			}
			if ($params.new_vcsa.network.gateway) {
				$OvfConfiguration.Common.guestinfo.cis.appliance.net.gateway.Value = $params.new_vcsa.network.gateway
			}
			if ($params.new_vcsa.network.dns_servers) {
				$OvfConfiguration.Common.guestinfo.cis.appliance.net.dns.servers.Value = $params.new_vcsa.network.dns_servers
			}
			if ($params.new_vcsa.network.system_name) {
				$OvfConfiguration.Common.guestinfo.cis.appliance.net.pnid.Value = $params.new_vcsa.network.system_name
			}
			if ($params.new_vcsa.sso.password) {
				$OvfConfiguration.Common.guestinfo.cis.vmdir.password.Value = $params.new_vcsa.sso.password
			}
			if ($params.new_vcsa.os.password) {
				$OvfConfiguration.Common.guestinfo.cis.appliance.root.passwd.Value = $params.new_vcsa.os.password
			}
			if ($params.ceip.settings.ceip_enabled) {
				$OvfConfiguration.Common.guestinfo.cis.ceip_enabled.Value = $params.ceip.settings.ceip_enabled
			}
			if ($params.new_vcsa.appliance.deployment_option) {
				$OvfConfiguration.DeploymentOption.Value = $params.new_vcsa.appliance.deployment_option
			}
			if ($params.new_vcsa.vc.deployment_network) {
				$OvfConfiguration.NetworkMapping.Network_1.Value = $params.new_vcsa.vc.deployment_network
			}
			if ($params.new_vcsa.network.domain) {
				$OvfConfiguration.vami.VMware_vCenter_Server_Appliance.domain.Value = $params.new_vcsa.network.domain
			}
			if ($params.new_vcsa.network.searchpath) {
				$OvfConfiguration.vami.VMware_vCenter_Server_Appliance.searchpath.Value = $params.new_vcsa.network.searchpath
			}
			if ($OvfConfiguration.EULAs.Accept) {
				$OvfConfiguration.EULAs.Accept.Value = $true
			}
	
			Return $OvfConfiguration
		}
	}
	
	$ErrorActionPreference = 'Stop'
		
	Write-Host -ForegroundColor Gray "************************************************************"
	Write-Host -ForegroundColor Gray "** Starting vCenter Server Appliance appliance deployment **"
	Write-Host -ForegroundColor Gray "************************************************************"
	Write-Host ""
		
	# Get JSON parameters from the specified config file which should be set in the OVF parameters hashtable.
	# If the path does not exist or the path is not a JSON exit the script with an error.
	Write-Host -ForegroundColor Cyan "Validate the provided JSON..."
	Write-Host -ForegroundColor Cyan "*****************************"
	Try {
		Write-Host -ForegroundColor Magenta "Checking the provided JSON path..."
		if (Resolve-Path $JSONPath -ErrorAction Stop) {
			Write-Host -ForegroundColor Magenta "Successfully resolved the provided path. Checking the extension..."
			if (([IO.Path]::GetExtension($JSONPath)) -ne ".json") {
				Write-Warning "The file extension specified is not supported. Retry the deployment with a .json extension. Stopping the script."
			}
			Write-Host -ForegroundColor Green "Provided path is a valid JSON extension."
			Write-Host ""
		}
		$paramDataJSON = Get-Content -Path $JSONPath | Out-String
	}
	Catch {
		Write-Host ""
		Write-Warning "The file path $JSONPath does not exist. Please retry the deployment with another path to the vCenterServer configuration JSON."
		Return 1
	}
	#$paramDataJSON = Get-Content -Path $JSONPath | Out-String
	# Try to convert the json file to a PowerShell object. If the file is not a valid JSON, exit the script.
	Write-Host -ForegroundColor Cyan "Performing JSON conversion to PSObject"
	Write-Host -ForegroundColor Cyan "**************************************"
	Try {
		Write-Host -ForegroundColor Magenta "Converting the JSON to a PowerShell object."
		$paramData = ConvertFrom-Json -InputObject $paramDataJSON -ErrorAction Stop
		#$paramData = ConvertFrom-Json -InputObject $JSON -ErrorAction Stop
	}
	Catch {
		Write-Host ""
		Write-Warning "Could not convert the JSON file specified. $_"
		Return 1
	}
		
	Write-Host -ForegroundColor Green "Successfully converted the specfied JSON."
	Write-Host ""
		
	Write-Host -ForegroundColor Cyan "Checking if VM exists on the destination"
	Write-Host -ForegroundColor Cyan "****************************************"
		
	If (Get-VM $paramData.new_vcsa.appliance.name -ErrorAction SilentlyContinue) {
		Write-Host -ForegroundColor Green "The VM $($paramData.new_vcsa.appliance.name) already exists on the target vCenter Server."
		Return 0
	}
	Write-Host -ForegroundColor Green "The VM $($paramData.new_vcsa.appliance.name) was not found on the target vCenter Server. Continuing..."
	Write-Host ""
		
	# Try to obtain the OVF configuration data from the specified OVA.
	# If the OVA cannot be located exit the script.
	Write-Host -ForegroundColor Cyan "Getting the OVF properties from the specified OVA"
	Write-Host -ForegroundColor Cyan "*************************************************"
	Try {
		Write-Host -ForegroundColor Magenta "Getting the OVF properties from OVA $($OVAName)."
		$ovf = Get-OvfConfiguration -ContentLibraryItem $OVAName -Target ($paramData.new_vcsa.vc.vmhost) -ErrorAction Stop
	}
	Catch {
		Write-Warning "The specified ova $OVAName could not be located in the target vCenter Server's content libraries."
		Write-Warning "Please correct the name or upload the desired vCenter Server OVA and retry the deployment."
		Return 1
	}
	Write-Host -ForegroundColor Green "Successfully acquired the appliance OVF properties from the OVA."
	Write-Host ""
		
	# Determine destination ESXi host (required New-VM parameter). Will get a host from a cluster object.
	$obj = Get-Inventory -Name $paramData.new_vcsa.vc.vmhost
	if ($obj -is [VMware.VimAutomation.ViCore.Impl.V1.Inventory.ComputeResourceImpl]) {
		$obj = Get-VMHost -Location $obj | Get-Random
	}
	$esx = $obj
		 
	# Set the destination datastore for the VM.
	$ds = Get-Datastore -Name $paramData.new_vcsa.vc.datastore -ErrorAction SilentlyContinue
		
	# Set OVF parameters for the VM deployment
	Write-Host -ForegroundColor Cyan "Setting the OVF properties from the specified OVA"
	Write-Host -ForegroundColor Cyan "*************************************************"
	Write-Host -ForegroundColor Magenta "Setting the OVF properties to apply to the virtual appliance from the specified JSON."
	$ovfParam = Set-OvfParameters $paramData $ovf
		  
	Write-Host -ForegroundColor Magenta "Setting the OVF properties to the new VM configuration."
	# VM configuration hashtable. Used to deploy a new VM.
	$sVApp = @{
		Name               = $paramData.new_vcsa.appliance.name
		VMHost             = $esx
		Datastore          = $ds
		DiskStorageFormat  = [VMware.VimAutomation.ViCore.Types.V1.VirtualDevice.VirtualDiskStorageFormat]::Thin
		ContentLibraryItem = $OVAName
		OvfConfiguration   = $ovfParam
		Confirm            = $false
	}
	Write-Host -ForegroundColor Green "Successfully set the new VM configuration properties."
	Write-Host ""
		  
	# Add a folder location to the confguration hashtable if a folder location has been specified in the config file.
	Write-Host -ForegroundColor Cyan "Setting VM folder if specified in the JSON payload"
	Write-Host -ForegroundColor Cyan "**************************************************"
		  
	if ($paramData.new_vcsa.vc.vm_folder) {
		# If the configuration JSON contains a folder name check if the folder exists.
		Write-Host -ForegroundColor Magenta "Folder specified. Checking if folder exists..."
		$data = get-folder -Type VM | Where-Object { $_.name -eq $paramData.new_vcsa.vc.vm_folder }
			
		# If the folder does not exist, create the folder in the VM root.
		if (!($data)) {
			Write-Host -ForegroundColor Red "Folder does not exist on destination."
			Write-Host -ForegroundColor Magenta "Creating folder $($paramData.VM.Folder)"
			Get-Folder vm | New-Folder $paramData.new_vcsa.vc.vm_folder -ErrorAction SilentlyContinue
			Write-Host -ForegroundColor Green "Create VM folder $paramData.new_vcsa.vc.vm_folder."
		}
		else {
			Write-Host -ForegroundColor Green "Specified folder already exists."
		}
			
		# Add the folder as a location parameter to the deployment options.
		#$sVApp.Add('InventoryLocation',(Get-Folder $paramData.VM.Folder))
		$sVApp.Add('Location', (Get-Folder $paramData.new_vcsa.vc.vm_folder))
	}
	else {
		Write-Host -ForegroundColor Green "No folder was specified in the JSON payload"
	}
	#$vm = Import-VApp @sVApp
		  
	#Deploy a new VM using the configuration hashtable. If the VM fails to be created, stop the script.
	Write-Host ""
	Write-Host -ForegroundColor Cyan "Deploy vCenter Server appliance"
	Write-Host -ForegroundColor Cyan "*******************************"
	try {
		Write-Host -ForegroundColor Magenta "Deploying vCenter appliance..."
		New-VM @sVApp -ErrorAction Stop
	}
	catch {
		Write-Host ""
		Write-Warning "Could not create VM $($paramData.new_vcsa.appliance.name)"
		Write-Host -ForegroundColor Yellow -BackgroundColor Black "$_.Exception"
		Write-Host -ForegroundColor Yellow -BackgroundColor Black "Check destination host logs for more information."
		Return 1
	}
	Write-Host -ForegroundColor Green "Successfully deployed VM $($paramData.new_vcsa.appliance.name)"
		
	# Once the vCenter appliance is deployed, add additional properties to the VM before starting the VM.
	# These properties are required to fully configure the vCenter Server appliance automatically.
	# If the properties are not applied the vCenter Server will require Stage 2 configuration manually.
		
	# Get the vCenter Server appliance VM object.
	$vm = Get-VM -Name $paramData.new_vcsa.appliance.name
		
	# Create the addtional configuration properties hashtable.
	$vAppProperties = @{
		"guestinfo.cis.appliance.ntp.servers" = $paramData.new_vcsa.os.ntp_servers
		"guestinfo.cis.appliance.ssh.enabled" = $paramData.new_vcsa.os.ssh_enabled
		"guestinfo.cis.silentinstall"         = "True"
		"guestinfo.cis.deployment.autoconfig" = "True"
	}
		
	# Set the additional properties on the vCenter Server appliance VM. This function is a custom function from William Lam.
	Write-Host ""
	Write-Host -ForegroundColor Cyan "Set VM OVF Properties"
	Write-Host -ForegroundColor Cyan "*********************"
	Write-Host -ForegroundColor Magenta "Setting the OVF properties to apply to the virtual appliance from the specified JSON."
	Set-VMOvfProperty -VM $vm -ovfChanges $vAppProperties
		
	# Power on the new Virtual Machine.
	Write-Host ""
	Write-Host -ForegroundColor Cyan "Power on the VM"
	Write-Host -ForegroundColor Cyan "***************"
	try {
		Write-Host -ForegroundColor Magenta "Starting VM $($paramData.new_vcsa.appliance.name)"
		Start-VM $vm
	}
	catch {
		Write-Host ""
		Write-Warning "Could not start VM $($paramData.new_vcsa.appliance.name)."
		Write-Host -ForegroundColor Yellow -BackgroundColor Black "$_.Exception"
		Write-Host -ForegroundColor Yellow -BackgroundColor Black "Check destination host logs for more information."
		Return 1
	}
	Write-Host -ForegroundColor Green "Successfully started VM $($paramData.new_vcsa.appliance.name)"
		
	# Start checking if the appliance services are available. It may take up to 20 minutes to complete the appliance configuration.
	Write-Host ""
	Write-Host -ForegroundColor Cyan "Check appliance availability"
	Write-Host -ForegroundColor Cyan "****************************"
	Write-Host -ForegroundColor Magenta "Attempting to connect to $($paramData.new_vcsa.network.system_name) to validate it has come online properly."
	
	$i = 0
	do {
		Write-Host "$($paramData.new_vcsa.network.system_name) is not currently available. Retrying in 60 seconds."
		$i++
		Start-Sleep 60
	}
	until (($vi = connect-viserver -server $paramData.new_vcsa.network.system_name -user "administrator@vsphere.local" -password $paramData.new_vcsa.sso.password -ErrorAction SilentlyContinue) -or ($i -eq 25))
	
	#If the connection was successful inform the operator so.
	if ($vi) {
		Write-Host -ForegroundColor Green "Successfully connected to vCenter Server"
		Disconnect-VIServer -Server $vi -Confirm:$false
	}
	#If the connection was unsuccessful inform the operator the vCenter Server may still be configuring but the timeout was met.
	else {
		Write-Warning "Could not connect to vCenter Server . Timeout of 20 minutes was reached."
		Write-Warning "Check the vCenter Server appliance for more details. It may still be configuring."
		return 1
	}
		
	Write-Host -ForegroundColor Green "vCenter Server Appliance $($paramData.new_vcsa.appliance.name) successfully deployed!"
		  
	#Return the connection status for the vCenter Appliance so it may be used to perform other configurations.
	return 0
}