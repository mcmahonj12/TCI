#Requires -Modules VMware.VimAutomation.Core
function Install-vRO {
    <#
    .SYNOPSIS
    This PowerCLI cmdlet create a PowerCli object OvfConfiguration specifically designed to be used when importing the VMware-Telco-Cloud-Automation-2.1.0-20142564 ovf/ova package with the Import-VApp cmdlet.
    It relies on the get-ovfconfiguration PowerCli cmdlet
    
    .DESCRIPTION
    This function is based on the original get-ovfconfiguration PowerCLI cmdlet...
    ...and convert it in a Powershell friendly function specifically for the package VMware-Telco-Cloud-Automation-2.1.0-20142564
    It is mandatory to be connected to one vCenter or Get-OvfConfiguration will throw an error
    
    .NOTES
    Author: Jim McMahon II
    Original: Christophe Calvet
    Blog: http://www.thecrazyconsultant.com/Get-OvfConfiguration_on_steroids
    
    .LINK
    This function has been generated by script for a VMware-Telco-Cloud-Automation-2.1.0-20142564 ovf/ova package then modified to use a JSON payload.
    The script used to create this function is available at the link below, and can be used for any ovf/ova packages.
    http://www.thecrazyconsultant.com/Get-OvfConfiguration_on_steroids
    Documentation for the original get-ovfconfiguration
    http://pubs.vmware.com/vsphere-55/index.jsp#com.vmware.powercli.cmdletref.doc/Get-OvfConfiguration.html
    Link for a good overview of get-ovfconfiguration
    http://blogs.vmware.com/PowerCLI/2014/09/powercli-5-8-new-feature-get-ovfconfiguration-part-1-2.html
    
    .PARAMETER jsonpath
    Specifies the file path to the json payload to be used to deploy a vCenter Server appliance. This payload is used to create the OVF properties object.
  
    .PARAMETER ovfpath
    Specifies the local path to the OVF or OVA package for which the user-configurable options are returned. URL paths are not supported.
    #>
    [cmdletbinding()]
    param(
        ## Specifies the json payload to be used to create an OVF properties object.
        [Parameter(Mandatory = $true)]
        [string]$JSONPath,
    
        ## Specifies the name of the OVA used to deploy the vRealize Orchestrator appliance.
        [Parameter(Mandatory = $true)]
        [string]$OVAName
    )
  
    function Set-OvfParameters($params, $OvfConfiguration) {  

        # Set the OVF properties from the accepted JSON payload.
        process {
          
            if ($params.Common.FIPSMode) {
                $OvfConfiguration.Common.fips_mode.Value = $params.Common.FIPSMode
            }
            if ($params.Common.k8s_cluster_cidr) {
                $OvfConfiguration.Common.k8s_cluster_cidr.Value = $params.Common.k8s_cluster_cidr
            }
            if ($params.Common.k8s_service_cidr) {
                $OvfConfiguration.Common.k8s_service_cidr.Value = $params.Common.k8s_service_cidr
            }
            if ($params.Network.NTPServers) {
                $OvfConfiguration.Common.ntp_servers.Value = $params.Network.NTPServers
            }
            if ($params.Common.Hostname) {
                $OvfConfiguration.Common.vami.hostname.Value = $params.Common.Hostname
            }
            if ($params.Common.Root_password) {
                $OvfConfiguration.Common.varoot_password.Value = $params.Common.Root_password
            }
            if ($params.Common.SSH_Enabled) {
                $OvfConfiguration.Common.va_ssh_enabled.Value = $params.Common.SSH_Enabled
            }
            if ($params.Network.IpProtocol) {
                $OvfConfiguration.IpAssignment.IpProtocol.Value = $params.Network.IpProtocol
            }
            if ($params.Network.Portgroup) {
                $OvfConfiguration.NetworkMapping.Network_1.Value = $params.Network.Portgroup
            }
            if ($params.Network.DNSServers) {
                $OvfConfiguration.vami.VMware_vRealize_Orchestrator_Appliance.DNS.Value = $params.Network.DNSServers
            }
            if ($params.Network.Domain) {
                $OvfConfiguration.vami.VMware_vRealize_Orchestrator_Appliance.domain.Value = $params.Network.Domain
            }
            if ($params.Network.Gateway) {
                $OvfConfiguration.vami.VMware_vRealize_Orchestrator_Appliance.gateway.Value = $params.Network.Gateway
            }
            if ($params.Network.IPAddress) {
                $OvfConfiguration.vami.VMware_vRealize_Orchestrator_Appliance.ip0.Value = $params.Network.IPAddress
            }
            if ($params.Network.Netmask) {
                $OvfConfiguration.vami.VMware_vRealize_Orchestrator_Appliance.netmask0.Value = $params.Network.Netmask
            }
            if ($params.Network.SearchPath) {
                $OvfConfiguration.vami.VMware_vRealize_Orchestrator_Appliance.searchpath.Value = $params.Network.SearchPath
            }
            if ($OvfConfiguration.EULAs.Accept) {
                $OvfConfiguration.EULAs.Accept.Value = $true
            }
          
            Return $OvfConfiguration
        }
    }

    function Get-ServiceAvailability($hostname) {

        $endpoint = "/vco-controlcenter/config/api/server/about"
        $uri = "https://" + $hostname + $endpoint
    
        # Set the certificate trust policy to accept unsigned certificates due to self-signed certs at initial deploy.
        add-type @"
        using System.Net;
        using System.Security.Cryptography.X509Certificates;
        public class TrustAllCertsPolicy : ICertificatePolicy {
            public bool CheckValidationResult(
                ServicePoint srvPoint, X509Certificate certificate,
                WebRequest request, int certificateProblem) {
                return true;
            }
        }
"@
    [System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    
    [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor [System.Net.SecurityProtocolType]::Tls12
    
    
        # Set the headers and make the API call to check if the web service is up. The response should return a 200 despite no auth.
        $headers=@{}
        $headers.Add("Content-Type", "application/json")
        $headers.Add("Accept", "application/json")
        $response = Invoke-WebRequest -Uri $uri -Method GET -Headers $headers -ErrorAction SilentlyContinue
        #$response = Invoke-WebRequest -Uri 'https://vro.frankenlab.foobar/vco-controlcenter/config/api/server/about' -Method GET -Headers $headers
    
        Return $response
    }

    $ErrorActionPreference = 'Stop'
	
    Write-Host -ForegroundColor Gray "*********************************************************"
    Write-Host -ForegroundColor Gray "** Starting vRealize Orchestrator appliance deployment **"
    Write-Host -ForegroundColor Gray "*********************************************************"
    Write-Host ""
  
    # Get JSON parameters from the specified config file which should be set in the OVF parameters hashtable.
    # If the path does not exist or the path is not a JSON exit the script with an error.
    Write-Host -ForegroundColor Cyan "Validate the provided JSON..."
    Write-Host -ForegroundColor Cyan "*****************************"
    Try {
        Write-Host -ForegroundColor Magenta "Checking the provided JSON path..."
        if (Resolve-Path $JSONPath -ErrorAction Stop) {
            Write-Host -ForegroundColor Magenta "Successfully resolved the provided path. Checking the extension..."
            if (([IO.Path]::GetExtension($JSONPath)) -ne ".json") {
                Write-Warning "The file extension specified is not supported. Retry the deployment with a .json extension. Stopping the script."
            }
            Write-Host -ForegroundColor Green "Provided path is a valid JSON extension."
            Write-Host ""
        }
        $paramDataJSON = Get-Content -Path $JSONPath | Out-String
    }
    Catch {
        Write-Host ""
        Write-Warning "The file path $JSONPath does not exist. Please retry the deployment with another path to the vRealize Orchestrator configuration JSON."
        Return 1
    }
    #$paramDataJSON = Get-Content -Path $JSONPath | Out-String
    # Try to convert the json file to a PowerShell object. If the file is not a valid JSON, exit the script.
    Write-Host -ForegroundColor Cyan "Performing JSON conversion to PSObject"
    Write-Host -ForegroundColor Cyan "**************************************"
    Try {
        Write-Host -ForegroundColor Magenta "Converting the JSON to a PowerShell object."
        $paramData = ConvertFrom-Json -InputObject $paramDataJSON -ErrorAction Stop
        #$paramData = ConvertFrom-Json -InputObject $JSON -ErrorAction Stop
    }
    Catch {
        Write-Host ""
        Write-Warning "Could not convert the JSON file specified. $_"
        Return 1
    }
	
    Write-Host -ForegroundColor Green "Successfully converted the specfied JSON."
    Write-Host ""
	
    Write-Host -ForegroundColor Cyan "Checking if VM exists on the destination"
    Write-Host -ForegroundColor Cyan "****************************************"
	
    If (Get-VM $paramData.VM.VMName -ErrorAction SilentlyContinue) {
        Write-Host -ForegroundColor Green "The VM $($paramData.VM.VMName) already exists on the target vCenter Server."
        Return 0
    }
	
    Write-Host -ForegroundColor Green "The VM $($paramData.VM.VMName) was not found on the target vCenter Server. Continuing..."
    Write-Host ""

    # Try to obtain the OVF configuration data from the specified OVA.
    # If the OVA cannot be located exit the script.
    Write-Host -ForegroundColor Cyan "Getting the OVF properties from the specified OVA"
    Write-Host -ForegroundColor Cyan "*************************************************"
    Try {
        Write-Host -ForegroundColor Magenta "Getting the OVF properties from OVA $($OVAName)."
        $ovf = Get-OvfConfiguration -ContentLibraryItem $OVAName -Target ($paramData.vsphere.vmhost) -ErrorAction Stop
    }
    Catch {
        Write-Warning "The specified ova $OVAName could not be located in the target vCenter Server's content libraries."
        Write-Warning "Please correct the name or upload the desired vRealize Orchestrator OVA and retry the deployment."
        Return 1
    }
    Write-Host -ForegroundColor Green "Successfully acquired the appliance OVF properties from the OVA."
    Write-Host ""
  
    # Determine destination ESXi host (required New-VM parameter). Will get a host from a cluster object.
    $obj = Get-Inventory -Name $paramData.vSphere.VMHost
    if ($obj -is [VMware.VimAutomation.ViCore.Impl.V1.Inventory.ComputeResourceImpl]) {
        $obj = Get-VMHost -Location $obj | Get-Random
    }
    $esx = $obj
   
    # Set the destination datastore for the VM.
    $ds = Get-Datastore -Name $paramData.vSphere.Datastore -ErrorAction SilentlyContinue
  
    # Set OVF parameters for the VM deployment
    Write-Host -ForegroundColor Cyan "Setting the OVF properties from the specified OVA"
    Write-Host -ForegroundColor Cyan "*************************************************"
    Write-Host -ForegroundColor Magenta "Setting the OVF properties to apply to the virtual appliance from the specified JSON."

    $ovfParam = Set-OvfParameters $paramData $ovf
   
    # VM configuration hashtable. Used to deploy a new VM.
    $sVApp = @{
        Name               = $paramData.VM.VMName
        VMHost             = $esx
        Datastore          = $ds
        DiskStorageFormat  = [VMware.VimAutomation.ViCore.Types.V1.VirtualDevice.VirtualDiskStorageFormat]::Thin
        #Source            = $paramData.vSphere.OvaPath
        ContentLibraryItem = $OVAName
        OvfConfiguration   = $ovfParam
        Confirm            = $false
    }
    Write-Host -ForegroundColor Green "Successfully set the new VM configuration properties."
    Write-Host ""
	 
    # Add a folder location to the confguration hashtable if a folder location has been specified in the config file.
    Write-Host -ForegroundColor Cyan "Setting VM folder if specified in the JSON payload"
    Write-Host -ForegroundColor Cyan "**************************************************"
	
    if ($paramData.VM.Folder) {
        # If the configuration JSON contains a folder name check if the folder exists.
        Write-Host -ForegroundColor Magenta "Folder specified. Checking if folder exists..."
        $data = get-folder -Type VM | Where-Object { $_.name -eq $paramData.VM.Folder }
		
        # If the folder does not exist, create the folder in the VM root.
        if (!($data)) {
            Write-Host -ForegroundColor Red "Folder does not exist on destination."
            Write-Host -ForegroundColor Magenta "Creating folder $($paramData.VM.Folder)"
            Get-Folder vm | New-Folder $paramData.VM.Folder -ErrorAction SilentlyContinue
            Write-Host -ForegroundColor Green "Created VM folder $($paramData.VM.Folder)."
        }
        else {
            Write-Host -ForegroundColor Green "Specified folder already exists."
        }
		
        # Add the folder as a location parameter to the deployment options.
        #$sVApp.Add('InventoryLocation',(Get-Folder $paramData.VM.Folder))
        $sVApp.Add('Location', (Get-Folder $paramData.VM.Folder))
    }
    #$vm = Import-VApp @sVApp
  
    #Deploy a new VM using the configuration hashtable. If the VM fails to be created, stop the script.
    Write-Host ""
    Write-Host -ForegroundColor Cyan "Deploy vCenter Server appliance"
    Write-Host -ForegroundColor Cyan "*******************************"
    try {
        Write-Host -ForegroundColor Green "Deploying vRealize Orchestrator appliance..."
        New-VM @sVApp -ErrorAction Stop
    }
    catch {
        Write-Host ""
        Write-Warning "Could not create VM $($paramData.VM.VMName)"
        Write-Host -ForegroundColor Yellow -BackgroundColor Black "$_.Exception"
        Write-Host -ForegroundColor Yellow -BackgroundColor Black "Check destination host logs for more information."
        Return 1
    }
    Write-Host -ForegroundColor Green "Successfully deployed VM $($paramData.VM.VMName)"
  
    #Get the vRealize Orchestrator appliance VM object.
    $vm = Get-VM -Name $paramData.VM.VMName
  
    #Power on the new Virtual Machine.
    Write-Host ""
    Write-Host -ForegroundColor Cyan "Power on the VM"
    Write-Host -ForegroundColor Cyan "***************"
    try {
        Write-Host -ForegroundColor Magenta "Starting VM $($paramData.VM.VMName)"
        Start-VM $vm
    }
    catch {
        Write-Warning "Could not start VM $($paramData.VM.VMName)."
        Write-Host -ForegroundColor Yellow -BackgroundColor Black "$_.Exception"
        Write-Host -ForegroundColor Yellow -BackgroundColor Black "Check destination host logs for more information."
        Return 1
    }

    #Start checking if the appliance services are available.
    Write-Host ""
    Write-Host -ForegroundColor Cyan "Check appliance availability"
    Write-Host -ForegroundColor Cyan "****************************"

    # Check if the VM exists
    if (Get-VM $paramData.VM.VMName -ErrorAction SilentlyContinue) {
        Write-Host -ForegroundColor Magenta "VM $($paramData.VM.VMName) was found on the destination vCenter Server."
        Write-Host -ForegroundColor Magenta "Attempting to connect to $($paramData.common.hostname) to validate it has come online properly."
        $i = 0
        do {
            $result = Get-ServiceAvailability $paramData.common.hostname
            Write-Host "$($paramData.common.hostname) is not currently available. Retrying in 60 seconds."
            $i++
            Start-Sleep 60
        }
        until (($result.StatusCode -eq "200") -or ($i -eq 25))

    }
    else {
        Write-Warning "VM $($paramData.VM.VMName) was not found on the destination vCenter Server. Check the destination vCenter Server tasks and logs for more details."
        Return 1
    }
  	
    Write-Host -ForegroundColor Green "vRealize Orchestrator appliance $($paramData.VM.VMName) deployed successfully!"

    #Return the connection status so it may be used to perform other configurations.
    Return 0
}